\documentclass{article}

\usepackage[USenglish]{babel}
\usepackage{enumitem}
\usepackage{amssymb, amsmath}

\usepackage[normalem]{ulem}



\newtheorem{example}{Example}
\newtheorem{remark}{Remark}

\usepackage{alltt,xcolor}
\let\oldalltt\alltt
\renewenvironment{alltt}{\vspace{-0.75\baselineskip}\begin{oldalltt}}{\end{oldalltt}\vspace{+0.50\baselineskip}}

\usepackage{tikz}
\usepackage{graphicx}


\newcommand{\red}[1]{\textcolor{red}#1}
\newcommand{\green}[1]{{\color{green}#1}}
\newcommand{\blue}[1]{{\color{blue}#1}}
\newcommand{\purple}[1]{{\color{purple}#1}}
\newcommand{\orange}[1]{{\color{orange}#1}}

\newcommand{\hashjoin}[1]{\begin{array}{c} \mathtt{hashJoin} \\ \bowtie\\ {#1}\\ \end{array}}
\newcommand{\mergejoin}[1]{\begin{array}{c} \mathtt{mergeJoin} \\ \bowtie\\ {#1}\\ \end{array}}
\newcommand{\indexjoin}[1]{\begin{array}{c} \mathtt{indexJoin} \\ \bowtie\\ {#1}\\ \end{array}}
\newcommand{\nestedjoin}[1]{\begin{array}{c} \mathtt{nestedLoopJoin} \\ \bowtie\\ {#1}\\ \end{array}}

\newcommand{\sortprojection}[1]{\begin{array}{c} \mathtt{sortProjection} \\ \pi_{#1}\ \end{array}}
\newcommand{\hashprojection}[1]{\begin{array}{c} \mathtt{hashProjection} \\ \pi_{#1}\ \end{array}}

\newcommand{\scan}[1]{\begin{array}{c} \mathtt{scan} \\ {#1}\ \end{array}}

\newcommand{\filter}[1]{\begin{array}{c} \mathtt{filterSselection}\\ \sigma_{#1}\ \end{array}}

\newcommand{\filterscan}[2]{\begin{array}{c} \mathtt{filterScan}\\ \sigma_{#1}(#2)\ \end{array}}
\newcommand{\sortfilterscan}[2]{\begin{array}{c}\mathtt{sort} \mathtt{filterScan}\\ \sigma_{#1}(#2)\ \end{array}}
\newcommand{\hashfilterscan}[2]{\begin{array}{c}\mathtt{hash} \mathtt{hashfilterScan}\\ \sigma_{#1}(#2)\ \end{array}}

\newcommand{\alltext}[2]{\begin{alltt}\textcolor{#1}{#2}\end{alltt}}

\begin{document}

\title{B561 Assignment 7\\
\ \\
Testing Effectiveness of Query Optimization; \\
Object-Relational Database Programming \\
Key-Value Databases and Graph Databases (Draft) }
\author{Dirk Van Gucht}
\date{}
\maketitle

This assignment focuses on problems related to Lecture 9 and Lectures 18 through 22.
\begin{itemize}
\item Lecture 18:  Algorithms for RA operations
\item Lecture 19:  Query processing and query plans
\item Lecture 20:  Object-relational database programming
\item Lecture 20:  Key-value stores.  NoSQL in MapReduce style
\item Lecture 21:  Key-value stores;  NoSQL in Spark style
\item Lecture 22:  Graph databases
\end{itemize}
Other lectures that a relevant for this assignment are Lectures 8, 13, and 14:
\begin{itemize}
\item Lecture 8:  Translating Pure SQL queries into RA expressions
\item Lecture 9:  Query optimization
\item Lecture 13:  Object-Relational databases and queries
\item Lecture 14:  Nested Relational, Semi-structured Databases, Document Databases
\end{itemize}
\vfill

This assignment has problems that are required to be solved.  Others, identified as such, are practice problems that you should attempt since the serve as preparation for the final exam.

Turn in a single {\tt assignment7.sql} file that contains the PostgreSQL code of the solutions for the problem that require such code.   
(Do not include solutions for the practice problems.)
Also turn in a {\tt assignment7.txt} file that contains all the output associated with the problems
in this assignment.
For all the other problems, submit a single {\tt assignment7.pdf} file with your solutions.

\vfill
\newpage
\section{Analysis of Queries Using Query Plans}

Consider Lecture 19 on Query Processing: Query Planning in (Object) Relational Systems.
Consider the analysis, using query plans, for the {\tt SOME} quantifier.

\begin{enumerate}
\item Assume the relation schemas $P(x)$, $Q(x)$, $R(x,y)$ and $S(x,z)$.

Consider the {\tt NOT ALL} generalized query
\[\{(p.x,q.x) | P(p)\land Q(p) \land R(p.x) \not\supset S(p.x)\}\]
where
\[
\begin{array}{rcl}
R(p.x) & = & \{r.y\mid R(r) \land r.x = p.x\} \\
S(q.x) & = & \{s.z\mid S(s) \land s.x = q.x\} \\
\end{array}
\]

Consider Lecture 19 on \emph{Query Processing: Query Planning in (Object) Relational Systems} and
in particular the analysis, using query plans, for the {\tt SOME} generalized quantifier.

Now to the problem.
In analogy with the analysis for the {\tt SOME} generalized quantifier, do an analysis for the {\tt NOT ALL} generalized quantifier.
\end{enumerate}

\section{Experiments to Test the Effectiveness of Query Optimization}
In the following problems, you will conduct experiments in PostgreSQL to gain insight into
whether or not query optimization can be effective.  
In other words, can it be determined experimentally 
if optimizing an SQL or an RA expression improves the time (and space) complexity of query evaluation?
Additionally, can it be determined if the PostgreSQL query optimizer attains the same (i.e., better or worse)
optimization as optimization by hand.
Recall that in SQL you can specify each RA expression as an RA SQL query.   This implies that each of the
optimization rules for RA can be applied directly to queries formulated in RA SQL.

In the following problems you will need to generate artificial data
of increasing size and measure the time of evaluating non-optimized and
optimized queries.    The size of this data can be in the ten or hundreds of thousands of tuples.
This is necessary because on very small data is it is not possible to gain
sufficient insights into the quality (or lack of quality) of optimization.
You can use the data generation functions that were developed in Assignment 6.
Additionally, you are advised to examine the query plans generated by PostgreSQL.

For the problems in this assignments, we will use three relations:\footnote{A typical case could be where {\tt P} is {\tt Person},
{\tt R} is {\tt Knows}, and {\tt S} is the set of persons with the Databases skill.   Another case could where {\tt P} is the set of persons who
work for Amazon, {\tt R} is {\tt personSkill} and {\tt S} is the set of skills of persons who live in Bloomington. Etc.}
\begin{center}
\begin{tabular}{ll}
{\tt P(a int)} \\
{\tt R(a int, b int)} \\
{\tt S(b int)}
\end{tabular}
\end{center}

To generate {\tt P} or {\tt S}, you should use the function {\tt SetOfIntegers}
which generate a set of up to $n$ randomly selected  integers in the range $[l,u]$:
{\footnotesize
\begin{alltt}
\textcolor{blue}{
create or replace function SetOfIntegers(n int, l int, u int)
     returns table (x int) as
     $$  
        select floor(random() * (u-l+1) + l)::int as x 
        from   generate_series(1,n) 
        group by (x) order by 1;
     $$ language sql;
}
\end{alltt}
}
To generate {\tt R}, you should use the function {\tt BinaryRelationOverIntegers} which generates up to $n$
randomly selected pairs with first components in the range $[l_1,u_1]$ and second components in the range $[l_2,u_2]$:
{\footnotesize
\begin{alltt}
\textcolor{blue}{
create or replace function BinaryRelationOverIntegers(n int, l_1 int, u_1 int, l_2 int, u_2 int)
    returns table (x int, y int) as
    $$   
        select floor(random() * (u_1-l_1+1) + l_1)::int as x, 
               floor(random() * (u_2-l_2+1) + l_2)::int as y   
        from   generate_series(1,n)
        group by (x,y) order by 1,2;
     $$ language sql;
}
\end{alltt} 
}    

\begin{example}\label{queryQ1Q2}
Consider the query $Q_1$
\begin{alltt}\textcolor{blue}{
select distinct r1.a
from   R r1, R r2
where  r1.b = r2.a;}
\end{alltt}
\noindent
This query can be translated and optimized to the query $Q_2$
\begin{alltt}\textcolor{blue}{
select distinct r1.a
from   R r1 natural join (select distinct r2.a as b from R r2) r2;}
\end{alltt}
\noindent
Image that you have generated a relation ${\tt R}$.
Then when you execute  
\begin{alltt}\textcolor{blue}{
explain analyze
select distinct r1.a
from   R r1, R r2
where  r1.b = r2.a;}
\end{alltt}
\noindent
the system will return its query plan as well as the execution time
to evaluate $Q_1$ measured in ms.
And, when you execute
\begin{alltt}\textcolor{blue}{
explain analyze
select distinct r1.a
from   R r1 natural join (select distinct r2.a as b from R r2) r2;}
\end{alltt}
\noindent
the system will return its query plan as well as the execution time
to evaluate $Q_2$ measured in ms.
This permits us to compare the 
non-optimized query $Q_1$ with the optimized query $Q_2$ 
for various differently-sized relations $R$.
Here are some of these comparisons for various differently-sized random relations ${\tt R}$.
In this table, {\tt R} was generated with lower and upper bounds $l_1=l_2=1000$ and $u_1=u_2=1000$.\footnote{
%The ``$\mathtt{--}$" symbols indicates that I had to stop the experiment because it was taken too long.
All the experiments where done on a MacMini.}
\begin{center}
{\tt 
\begin{tabular}{l|r|r}
R & $Q_1$ (in ms) & $Q_2$ (in ms) \\ \hline
$10^4$  &          27.03                  &    7.80 \\
$10^5$   & 3176.53 &            58.36 \\
$10^6$   & 69251.58&  400.54 \\
\end{tabular}}
\end{center}
Notice the significant difference between the execution times of the
non-optimized query $Q_1$ and the optimized query $Q_2$.
So clearly, optimization works on query $Q_1$.

Incidentally, below are the query plans for $Q_1$ and $Q_2$.   Examining these query plans should reveal why $Q_1$ runs much slower than
$Q_2$. (Why?)
%\newpage
{\footnotesize
\begin{alltt}
\textcolor{purple}{
             QUERY PLAN for Q1          
------------------------------------
 HashAggregate
   Group Key: r1.a
   ->  Hash Join
         Hash Cond: (r1.b = r2.a)
         ->  Seq Scan on r r1
         ->  Hash
               ->  Seq Scan on r r2
}
\end{alltt}
}

{\footnotesize
\begin{alltt}
\textcolor{purple}{
                QUERY PLAN  for query Q2  
------------------------------------------
 HashAggregate
   Group Key: r1.a
   ->  Hash Join
         Hash Cond: (r1.b = r2.a)
         ->  Seq Scan on r r1
         ->  Hash
               ->  HashAggregate
                     Group Key: r2.a
                     ->  Seq Scan on r r2
}
\end{alltt}
}


\end{example}

\newpage
We now turn to the problems for this section.
\begin{enumerate}[resume]
\item \label{queryQ3Q4}
Consider query $Q_3$
\begin{alltt}\textcolor{blue}{
select distinct p.a
from   P p, R r1, R r2, R r3, S s
where  p.a = r1.a and r1.b = r2.a and r2.b = r3.a and r.b = S.b;}
\end{alltt}

Intuitively, if we view $\mathtt{R}$ as a graph, and $\mathtt{P}$ and
$\mathtt{S}$ as node types (properties), then $Q_3$ determines each $\mathtt{P}$-node in the graph from which there emanates a path of length $3$ that ends at a $\mathtt{S}$-node.\footnote{Such a query is typical in Graph Databases.}
I.e., a $\mathtt{P}$-node $n_0$ is
in the answer if there exists
sequence of nodes $(n_0,n_1,n_2,n_3)$ such that $(n_0,n_1)$, $(n_1,n_2)$, and $(n_2,n_3)$ are edges in $\mathtt{R}$ and $n_3$ is a $\mathtt{S}$-node.

\begin{enumerate}
\item Translate and optimize this query and call it $Q_4$.   Then write $Q_4$ as an RA SQL query 
just as was done for query $Q_2$ in Example~\ref{queryQ1Q2}.

\item Compare queries $Q_3$ and $Q_4$ in a similar way as we did for $Q_1$ and $Q_2$ in Example~\ref{queryQ1Q2}.

You should experiment with different sizes for ${\tt R}$.   Incidentally, these relations do not need to use the same parameters
as those shown in the above table for $Q_1$ and $Q_2$ in Example~\ref{queryQ1Q2}.

\item What conclusions do you draw from the results of these experiments regarding the effectiveness of query optimization in PostgreSQL and/or by hand?
\end{enumerate}

\newpage
\item \label{only}
Consider the Pure SQL $Q_5$ which is an formulation of a variation of the \emph{not subset (not only) set semijoin} query
\[\{p.a\mid \mathtt{P}(p)\,\land\, \mathtt{R}(p.a)\not\subseteq \mathtt{S}\} \]
where 
\[\mathtt{R}(p.a) =  \{r.b\mid \mathtt{R}(r)\land r.a = p.a\}.\]
{\footnotesize
\begin{alltt}\textcolor{blue}{
select p.a
from   P p
where  exists (select 1
               from   R r
               where  r.a = p.a and
                      not exists (select 1 from S s where r.b = s.b));}
\end{alltt}
}
\begin{enumerate}
\item Translate and optimize this query and call it $Q_6$.   Then write $Q_6$ as an RA SQL query just as was done for $Q_2$ 
in Example~\ref{queryQ1Q2}.

\item 
An alternative way to write a query equivalent with $Q_5$ is as the object-relational query
{\footnotesize
\begin{alltt}
\textcolor{blue}{
with nestedR as (select P.a, array_agg(R.b) as bs 
                 from   P natural join R
                 group by (P.a)),
     Ss as (select array(select b from S) as bs)
select a
from   nestedR
where  not (bs <@ (select bs from Ss));
}
\end{alltt}
}

Call this query $Q_7$.

Compare queries $Q_5$, $Q_6$, and $Q_7$ in a similar way as we did in Example~\ref{queryQ1Q2}.
However, now you should experiment with different sizes for {\tt P}, ${\tt R}$ and ${\tt S}$ as well as consider 
how ${\tt P}$ and ${\tt S}$ interact with $\mathtt{R}$.    
%For example, it could be that
%\begin{itemize}
%\item  $\pi_a(\mathtt{R})\subseteq \mathtt{P}$ 
%in which case attribute $\mathtt{a}$ in {\tt R} is a foreign key referencing attribute {\tt a} in {\tt P}; in this case, additional
%optimization is possible for queries $Q_6$ and $Q_7$;
%\item $\mathtt{P}\ltimes \mathtt{R} = \emptyset$ in which case the answer to the query is 
%equivalent with $\mathtt{P}$;
%\item $\mathtt{S} = \emptyset$ in which case the answer to the query is $\mathtt{P}-\pi_a({\mathtt R})$.
%\end{itemize}
%Still, the typical case would be where $\mathtt{P}$ is a small subset of $\pi_a(\mathtt{R})$ and $\mathtt{S}$ is a small 
%subset of $\pi_b(\mathtt{R})$.

\item What conclusions do you draw from the results of these experiments?
\end{enumerate}

\newpage
\item \label{all}
Consider the Pure SQL $Q_8$ which is an formulation of a variation of the \emph{not superset, (not all) set semijoin} query
\[\{p.a\mid |\mathtt{P}(p)\,\land\, R(p.a) \not\supseteq S\} \]
where 
\[\mathtt{R}(p.a) =  \{r.b\mid \mathtt{R}(r)\land r.a = p.a\}.\]

{\footnotesize
\begin{alltt}\textcolor{blue}{
select p.a
from   P p
where  exists (select 1
               from   S s
               where  not exists (select 1 from R where p.a = r.a and r.b = s.b));}
\end{alltt}
}
\begin{enumerate}
\item Translate and optimize this query and call it $Q_9$.   Then write $Q_9$ as an RA SQL query just as was done for $Q_2$ 
in Example~\ref{queryQ1Q2}.

\item 
An alternative way to write a query equivalent with $Q_8$ is as the object-relational query
{\footnotesize
\begin{alltt}
\textcolor{blue}{
with nestedR as (select P.a, array_agg(R.b) as bs 
                 from   P natural join R
                 group by (P.a)),
     Ss as (select array(select b from S) as bs)
select a
from   P
where  a not in (select a from nestedR) and
       not((select bs from Ss) <@ '\{\}')
union     
select a
from   nestedR
where  not((select bs from Ss) <@ bs);
}
\end{alltt}
}
Call this query $Q_{10}$.

Compare queries $Q_8$, $Q_9$, and $Q_{10}$ in a similar way as we did In Example~\ref{queryQ1Q2}.
However, now you should experiment with different sizes for {\tt P}, ${\tt R}$ and ${\tt S}$ as well as consider 
how ${\tt P}$ and ${\tt S}$ interact with $R$.    
For example, it could be that
%\begin{itemize}
%\item  $\pi_a(\mathtt{R})\subseteq \mathtt{P}$ 
%in which case attribute $\mathtt{a}$ in {\tt R} is a foreign key referencing attribute {\tt a} in {\tt P};
%\item $\mathtt{S} = \emptyset$ in which case the answer to the query is $\mathtt{P}$;
%\end{itemize}
%Still, the typical case would be where $\mathtt{P}$ is a small subset of $\pi_a(R)$ and $\mathtt{S}$ is a small 
%subset of $\pi_b(R)$.

\item What conclusions do you draw from the results of these experiments?
\end{enumerate}

\item  Give a brief comparison of your results for Problem~\ref{only} and Problem~\ref{all}.   In particular, where the results show significant differences, explain why you think that is the case.   And, where the results show similarities, explain why you think that is the case.
\end{enumerate}

\newpage
\section{Object Relational Programming}

The following problems require you to write object relational programs.   Many of these require program written in Postgres' {\tt plpgsql} database programming language.


\begin{enumerate}[resume]
\item \textcolor{red}{\bf Practice Problem--not graded}
Consider the relation schema {\tt V(node int)} and {\tt E(source int, target int)}
representing the schema for storing a directed graph $G$ with nodes in  {\tt V} and
edges in {\tt E}.

Now let $G$ be a directed graph that is {\bf acyclic}, i.e., a graph without cycles.
\footnote{A cycle is
a path $(n_0,\ldots, n_l)$ where $n_0=n_l$.}

A \emph{topological sort} of an acyclic graph $G$ is a list of {\bf all} nodes 
$(n_1,n_1,\ldots, n_k)$ in {\tt V} such that for each edge $(m,n)$ in $\mathtt{E}$,
node $m$ occurs before node $n$ in this list.   Note that a path can be stored in an array.

Write a PostgreSQL program {\tt topologicalSort()} that returns a
topological sort of $G$.

\item Consider a parent-child relation {\tt PC(parent, child)}. (You can assume that {\tt PC} is a rooted tree and the domain of the attributes {\tt parent} and {\tt child} is {\tt int}.)  An edge $(p,c)$ in {\tt PC} indicates
that node $p$ is a parent of node $c$.   Now consider a pair of nodes $(m,n)$ in {\tt PC} ($m$ and $n$ maybe the same nodes.)   We say that 
$m$ and $n$ are in the \emph{same generation} when the distance from $m$ to the root of {\tt PC} is the same as the distance from $n$ to the root of {\tt PC}.   

Consider the following recursive query that computes the {\tt sameGeneration} relation:
\begin{alltt}\textcolor{blue}{
WITH RECURSIVE sameGeneration(m, n) AS
     ((SELECT parent, parent FROM PC) UNION (select child, child from PC)
     UNION
     SELECT  t1.child, t2.child
     FROM    sameGeneration pair, PC t1, pc t2
     WHERE   pair.m = t1.parent and pair.n = t2.parent)
select distinct pair.m, pair.n from sameGeneration pair order by m, n;}
\end{alltt}

Write a non-recursive function {\tt sameGeneration()} in the language {\tt plpgsql} that computes the {\tt sameGeneration} relation.

\newpage



\item Consider the following relational schemas.  (You can assume that the domain of each of the attributes in these relations is {\tt int}.)
\begin{center}
{\tt 
\begin{tabular}{l}
partSubpart(\underline{pid,sid},quantity) \\
basicPart(\underline{pid},weight)
\end{tabular}
}
\end{center}

A tuple $(p, s, q)$  
is in {\tt partSubPart} if  part $s$ occurs $q$ times as a {\bf
    direct} subpart of part $p$.  For example, think of a car $c$ that has 4
  wheels $w$ and 1 radio $r$. Then $(c,w,4)$ and $(c,r,1)$ would be in {\tt partSubpart}.  Furthermore, then think of a wheel $w$ that has 5 bolts $b$.
  Then $(w,b,5)$ would be in {\tt partSubpart}.
  
  A  tuple $(p, w)$ is in {\tt basicPart} if basic part $p$ has
  weight $w$.  A basic part is defined as a part that does not have
  subparts.  In other words, the pid of a basic part does not occur
  in the pid column of {\tt partSubpart}.

 (In the above example, a bolt and a radio would be basic parts, but car and
 wheel would not be basic parts.)

We define the \emph{aggregated weight} of a part inductively as follows:
\begin{enumerate}
\item If $p$ is a basic part then its aggregated weight is its weight as given in
the {\tt basicPart} relation
\item If $p$ is not a basic part, then its aggregated weight is the
sum of the aggregated weights of its subparts, each multiplied by the
quantity with which these subparts occur in the {\tt partSubpart} relation.
\end{enumerate}

\newpage
\textbf{Example tables}: The following example is based on a desk
lamp with {\tt pid} $1$. Suppose a desk lamp consists of 4 bulbs (with {\tt pid} $2$)  and a frame (with {\tt pid} $3$), and a frame
consists of a post (with {\tt pid} $4$) and 2 switches (with {\tt pid} $5$). 
Furthermore, we will assume that the weight of a bulb is 5, that of a post is 50, and that of a switch
is 3. 

Then the {\tt partSubpart} and {\tt basicPart} relation would be as
follows:
\begin{center}
\begin{tabular}{ccc}
\begin{tabular}{c}
\textbf{partSubPart} \\ 
   \begin{tabular}{|c|c|c|} \hline
   pid & sid & quantity\\
   \hline
   1 & 2 & 4\\
   1 & 3 & 1\\
   3 & 4 & 1\\
   3 & 5 & 2\\
\hline
\end{tabular}\\
\end{tabular}
&
\begin{tabular}{c}
\textbf{basicPart}\\ 
   \begin{tabular}{|c|c|} \hline
   pid &weight\\
   \hline
   2 & 5\\
   4 & 50\\
   5 & 3\\
\hline
\end{tabular}\\
\end{tabular}
\end{tabular}
\end{center}


Then the aggregated weight of a lamp is $4\times 5 + 1\times( 1\times
50 + 2\times 3) = 76$.

\begin{enumerate}
\item Write a {\bf recursive} function {\tt recursiveAggregatedWeight(p integer)} that returns the aggregated weight of a part {\tt p}.   Test your function.
\item Write a {\bf non-recursive} function {\tt nonRecursiveAggregatedWeight(p integer)}
that returns the aggregated weight of a part {\tt p}.   Test your function.
\end{enumerate}

\newpage
\item \textcolor{red}{\bf Practice problem--not graded}.
Consider the heap data structure.   For a description, consult
\begin{center}
https://en.wikipedia.org/wiki/Binary\_heap.
\end{center}
\begin{enumerate}
\item\label{heap} Implement this data structure in PostgreSQL.   This implies that you need
to implement the {\tt insert} and {\tt extract} heap operations.

In this problem, you are {\bf not} allowed to use arrays to implement this data structure!
Rather you must you relations.

\item Then, using the heap data structure developed in question~\ref{heap}, write a PostgreSQL program {\tt heapSort()} that implement the {\tt Heapsort} algorithm.   For a description of this algorithm, see

\begin{center}
https://en.wikipedia.org/wiki/Heapsort
\end{center}

You are {\bf not} allowed to use arrays to implement this the {\tt Heapsort} algorithm!
\end{enumerate}

The input format is a list of integers stored in a binary relation {\tt Data(index,value)}.
For example, {\tt Data} could contain the following data.

\begin{center}
\begin{tabular}{c}
Data\\
\begin{tabular}{cc}
index & value \\ \hline
1        &  3 \\
2        &  1 \\
3       &   2 \\
4       &   0 \\
5      &    7 \\
\end{tabular}
\end{tabular}
\end{center}

The output of {\tt heapSort()} should be stored in a relation {\tt sortedData(index,value)}.
On the {\tt Data} relation above, this should be the following relation:

\newpage
\item \textcolor{red}{\bf Practice problem--not graded}. 
Suppose you have a weighted (directed) graph $G$ stored
  in a ternary table with schema
  \begin{center}
  {\tt Graph(source int, target int, weight int)}
  \end{center}
    A triple
  $(s,t,w)$ in Graph indicates that $Graph$ has an edge $(s,t)$ whose
  edge weight is $w$.
  (In this problem, we will assume that each edge weight is a positive
  integer.)

  Below  is an example of a graph $G$.


\begin{center}
\begin{tabular}{c}
{\tt Graph} $G$ \\
\begin{tabular}{|c|c|c|}\hline
source & target & weight \\ \hline\hline
0 & 1 & 2 \\
1 & 0 & 2 \\
0 & 4 & 10 \\
4 & 0 & 10 \\
1 & 3 & 3 \\
3 & 1 & 3 \\
1 & 4 & 7 \\
4 & 1 & 7 \\
2 & 3 & 4 \\
3 & 2 & 4 \\
3 & 4 & 5 \\
4 & 3 & 5 \\
4 & 2 & 6 \\ \hline
\end{tabular}
\end{tabular}
\end{center}

  Implement Dijkstra's Algorithm as a PostgreSQL function {\tt Dijkstra(s integer)}
  to compute the shortest path lengths (i.e., the distances) from some
  input vertex $s$ in $G$ to all other vertices in $G$. {\tt Dijkstra(s integer)}
  should accept an argument $s$, the source vertex, and outputs a table
  which represents the pairs $(t, d)$ where $d$ is the
  shortest distance from $s$ to $t$ in graph $G$. To test your procedure, you can
  use the graph shown above.


When you apply {\tt Dijkstra(0)}, you should obtain the
following table:

\begin{center}
\begin{tabular}{|c|c|}\hline
target & shortestDistance \\ \hline\hline
0 & 0 \\
1 & 2 \\
2 & 9 \\
3 & 5 \\
4 & 9 \\ \hline
\end{tabular}
\end{center}


\newpage

\item 
Consider the relation schema {\tt document(\underline{doc} int, words text[])} 
representing a relation of pairs $(d,W)$ where $d$ is a unique id denoting a document 
and $W$ denotes the set of words that occur in $d$.

Let ${\bf W}$ denote the set of all words that occur in the documents and
let $t$ be a positive integer denoting a \emph{threshold}. 
Let $X \subseteq {\bf W}$.   We say that $X$ is $t$-frequent if
\[{\tt count}(\{d| (d,W)\in {\tt document}\,\mbox{\rm and}\, X\subseteq W\}) \geq t\]
In other words, $X$ is \emph{$t$-frequent} if there are at least $t$ documents that contain
all the words in $X$.

Write a PostgreSQL program {\tt frequentSets(t int)} that returns the set of all $t$-frequent set.

In a good solution for this problem, you should use the following rule:
if $X$ is not $t$-frequent then any set $Y$ such that $X\subseteq Y$ is not $t$-frequent either.
In the literature, this is called the \emph{Apriori} rule of the frequent itemset mining problem.
This rule can be used as a pruning rule.   In other words, if you have determined that a
set $X$ in not $t$-frequent then you no longer have to consider any of $X$'s supersets.

To learn more about this problem you can visit the site\\ {\tt https://en.wikipedia.org/wiki/Apriori\_algorithm}.

Test your function {\tt frequentSets} for thresholds $0$ through $5$.

\newpage

\item Consider a directed graph $G$ stored in a relation {\tt Graph(source int, target int)}.  We say that 
$G$ is \emph{Hamiltonian} if $G$ has a cycle $(n_1,\ldots n_k)$ such that each node $n$ in $G$ occurs once, but only once, as a node $n_i$ in this cycle.

\begin{enumerate}
\item Write a {\bf recursive} function {\tt recursiveHamiltonian()} that returns {\tt true} if the
graph stored in {\tt Graph} is Hamiltonian, and {\tt false} otherwise.   Test your function.
\item Write a {\bf non-recursive} function {\tt nonRecursiveHamiltonian}
that returns {\tt true} if the
graph stored in {\tt Graph} is Hamiltonian, and {\tt false} otherwise.   Test your function.
\end{enumerate}



\end{enumerate}



\newpage


\section{Key-value Stores (MapReduce and Spark)}

Consider the document ``MapReduce and the New Software Stack" available in the module on MapReduce.\footnote{This is Chapter 2 in \emph{Mining of Massive Datasets} by
Jure Leskovec, Anand Rajaraman, and Jeffrey D. Ullman.}
In that document, you can, in Sections 2.3.3-2.3.7, find descriptions of
algorithms to implement relational algebra operations in MapReduce.   
(In particular, look at the mapper and reducer functions for various RA operators.)

\begin{remark}
Even though MapReduce as a top-level programming language is only rarely used, it still serves as an underlying
programming environment to which other languages compile.    Additionally, the programming techniques of applying maps to key-value stores
and reducing (accumulating, aggregating) intermediate and final results is an important feature of parallel and distributed data processing.
Additionally, the MapReduce framework forces one to reason about modeling data towards key-value stores.
Finally, the fact that the MapReduce programming model can be entirely simulated in the PostgreSQL object-relational system underscores again the versatility of this system for a broad range of database programming and application problems.
\end{remark}

In the following problems, you are asked to write MapReduce programs
that implement some RA operations and queries with aggregation in PostgreSQL.   In addition, you need to add
the code which permits the PostgreSQL simulations for these  MapReduce programs.   
%(Look in particular at the ``Additional Lecture Notes: Key-Value-MapReduce.pdf" file for details on how to do this.)

\paragraph{Discussion}
A crucial aspect of solving these problems is to develop an appropriate data representation for the input 
to these problems.   Recall that in MapReduce the input is a {\bf single} binary relation of $(key,value)$ pairs.

We will now discuss a general method for representing (encoding) a relational database in a single key-value store.
Crucial in this representation is the utilization of {\tt json} objects.\footnote{Incidentally, this modeling technique is independent of
MapReduce and can also be used to map relational data to other systems and programming languages that center around
{\tt json} objects.}

Consider a relation {\tt R(a,b,c)}.   For simplicity, we will assume that the domain of the attributes of {\tt R} is
integer.\footnote{However, this approach can be generalized for other domains such as string, booleans, etc.}

{\footnotesize
\begin{alltt}\textcolor{blue}{
create table R (a int, b int, c int);
insert into R values (1,2,3), (4,5,6), (1,2,4);
table R;

 a | b | c 
-----+---+---
 1 | 2 | 3
 4 | 5 | 6
 1 | 2 | 4
}\end{alltt}
}
\noindent
Starting from this relation {\tt R} we can, using {\tt jsonb}\footnote{PostgreSQL support both {\tt json} and {\tt jsonb} objects.  For this assignment, you should use the {\tt jsonb} object type since it comes with more functionality and offers more efficient computation.}
functions and operations on {\tt jsonb} objects, come up
with an encoding of {\tt R} as a key-value store.
Consider the tuple $$(1,2,3)$$ in {\tt R}.
We will represent (encode) this tuple as the key-value pair 
$$\mbox{\tt (`R',\{"a":1, "b":2, "c":3\})}.$$   So the key of this pair is the relation name `{\tt R}' and
the {\tt jsonb} object {\tt \{"a": 1, "b":2, "c": 1\}} represents the tuple $(1,2,3)$.
Based on this idea of representing tuples of {\tt R}, 
we can generate the entire key-value store for {\tt R} using an object-relational SQL query.\footnote{Notice that this strategy works in
general for any relation, independent of the number of attributes
of the relation.}
To that end, we can use the {\tt jsonb\_build\_object} PostgreSQL function.
{\footnotesize
\begin{alltt}\textcolor{blue}{
create table encodingofR (key text, value jsonb);

insert into encodingofR 
  select 'R' as key, jsonb_build_object('a', r.a, 'b', r.b, 'c', r.c) as value
  from   R r;
}\end{alltt}
}
\noindent
This gives the following encoding for {\tt R}. 
{\footnotesize
\begin{alltt}\textcolor{blue}{
table encodingofR;

key |            value            
-----+-----------------------------
R   | \{"a" : 1, "b" : 2, "c" : 3\}   
R   | \{"a" : 4, "b" : 5, "c" : 6\}   
R   | \{"a" : 1, "b" : 2, "c" : 4\}   
}\end{alltt}
}
\noindent
Note that we can also ``decode" the {\tt encodingofR} key-value store to recover {\tt R}  
by using the following object-relational SQL query.   To that end, we can use the {\tt jsonb} selector function {\tt ->}.

{\footnotesize
\begin{alltt}\textcolor{blue}{
select p.value->'a' as a, p.value->'b' as b, p.value->'c' as c 
from   encodingofR p;

a | b | c 
-----+---+---
1 | 2 | 3
4 | 5 | 6
1 | 2 | 4
}\end{alltt}
}

An important aspect of this encoding strategy is that it is
possible to put multiple relations, possible with different schemas and arities, into the same key-value store.
Besides {\tt R}, let us also consider a binary relation {\tt S(a,d)}.
{\footnotesize
\begin{alltt}\textcolor{blue}{
create table S (a int, d int);
insert into S values (1,2), (5,6), (2,1), (2,3);
table S;

a | d 
-----+
1 | 2 
5 | 6 
2 | 1 
2 | 3 
(4 rows)
}\end{alltt}
}
\noindent
We can now encode both {\tt R} and {\tt S} into a single key-value store {\tt encodingofRandS}
as follows:
{\footnotesize
\begin{alltt}\textcolor{blue}{
create table encodingofRandS(key text, value jsonb);

insert into encodingofRandS 
  select 'R' as key, jsonb_build_object('a', r.a, 'b', r.b, 'c', r.c) as value
  from   R r
  union
  select 'S' as key, jsonb_build_object('a', s.a, 'd', s.d) as value
  from   S s
  order by 1, 2;

table encodingofRandS;

key |          value           
-----+--------------------------
R   | \{"a": 1, "b": 2, "c": 3\}
R   | \{"a": 1, "b": 2, "c": 4\}
R   | \{"a": 4, "b": 5, "c": 6\}
S   | \{"a": 1, "d": 2\}
S   | \{"a": 2, "d": 1\}
S   | \{"a": 2, "d": 3\}
S   | \{"a": 5, "d": 6\}
(7 rows)
}\end{alltt}
}
\noindent
Furthermore, we can decode this key-value store using 2 object-relational SQL queries and
recover {\tt R} and {\tt S}.
{\footnotesize
\begin{alltt}\textcolor{blue}{
select p.value->'a' as a, p.value->'b' as b, p.value->'c' as c 
from   encodingofRandS p
where  p.key = 'R';

a | b | c 
-----+---+---
1 | 2 | 3
4 | 5 | 6
1 | 2 | 4
(3 rows)

select p.value->'a' as a, p.value->'d' as d
from   encodingofRandS p
where  p.key = 'S';

a | d 
-----+
1 | 2 
5 | 6 
2 | 1 
2 | 3 
(4 rows)
}\end{alltt}
}
\begin{example}
Consider the following problem.
Write, in PostgreSQL, a basic MapReduce program, i.e., a {\tt mapper}
function and a {\tt reducer} function, as well as a 3-phases simulation that
implements the set intersection of two unary relations {\tt R(a)} and
{\tt S(a)}, i.e., the relation ${\tt R} \cap {\tt S}$.  You can assume that the domain of
the attribute {\tt `a'} is integer.
{\footnotesize
\begin{alltt}\textcolor{blue}{
-- EncodingOfRandS;
drop table R; drop table S;

create table R(a int); 
insert into R values (1),(2),(3),(4);
create table S(a int);
insert into S values (2),(4),(5);

drop table EncodingOfRandS;
create table EncodingOfRandS(key text, value jsonb);

insert into EncodingOfRandS
   select 'R' as key, jsonb_build_object('a', r.a) as value
   from   R r
   union
   select 'S' as key, jsonb_build_object('a', s.a) as value
   from   S s
   order by 1;

table EncodingOfRandS;

 key |  value   
-----+----------
 R   | \{"a": 1\}
 R   | \{"a": 4\}
 R   | \{"a": 2\}
 R   | \{"a": 3\}
 S   | \{"a": 4\}
 S   | \{"a": 5\}
 S   | \{"a": 2\}
(7 rows)

-- mapper function
CREATE OR REPLACE FUNCTION mapper(key text, value jsonb)
RETURNS TABLE(key jsonb, value text) AS
$$
    SELECT value, key;
$$ LANGUAGE SQL;

-- reducer function
CREATE OR REPLACE FUNCTION reducer(key jsonb, valuesArray text[])
RETURNS TABLE(key text, value jsonb) AS
$$
    SELECT 'R intersect S'::text, key
    WHERE  ARRAY['R','S'] <@ valuesArray;
$$ LANGUAGE SQL;

-- 3-phases simulation of MapReduce Program followed by a decoding step
WITH
Map_Phase AS (
    SELECT m.key, m.value
    FROM   encodingOfRandS, LATERAL(SELECT key, value FROM mapper(key, value)) m
),
Group_Phase AS (
    SELECT key, array_agg(value) as value
    FROM   Map_Phase
    GROUP  BY (key)
),
Reduce_Phase AS (
    SELECT r.key, r.value
    FROM   Group_Phase, LATERAL(SELECT key, value FROM reducer(key, value)) r
)
SELECT p.value->'a' as a FROM Reduce_Phase p
order by 1;

a 
---
2
4
(2 rows)
}\end{alltt}
}

\end{example}

We now turn to the problems for this section.

\begin{enumerate}[resume]
\item \textcolor{red}{\bf Practice problem--not graded}. Write, in PostgreSQL, a basic MapReduce program, i.e., a {\tt mapper}
function and a {\tt reducer} function, as well as a 3-phases simulation that
implements the symmetric difference of two unary relations {\tt R(a)} and
{\tt S(a)}, i.e., the relation $({\tt R} - {\tt S})\cup({\tt S}-{\tt R})$.  You can assume that the domain of
the attribute {\tt `a'} is integer.

\item  Write, in PostgreSQL, a basic MapReduce program, i.e., a mapper function and a reducer function, as well as a 3-phases simulation 
that implements the semijoin of two
relations $\text{R(A,B)}$ and $\text{S(A,B,C)}$, i.e., the relation $R\,\ltimes\, S$.
You can assume that the domains of $A$, $B$, and $C$ are integer.
Use the encoding and decoding methods described above.

\item\label{join} \textcolor{red}{\bf Practice problem--not graded}. 
 Write, in PostgreSQL, a basic MapReduce program, i.e., a mapper function and a reducer function, as well as a 3-phases simulation 
that implements the natural join $R \bowtie S$ of two relations $\text{R(A, B)}$ and $\text{S(B,C)}$.
You can assume that the domains of $A$, $B$, and $C$ are integer.
Use the encoding and decoding methods described above.

\item  Write, in PostgreSQL, a basic MapReduce program, i.e., a mapper function and a reducer function, as well as a 3-phases simulation 
that implements the SQL query
\begin{alltt}\textcolor{blue}{
SELECT r.A, array_agg(r.B), sum(r.B)
FROM   R r
GROUP  BY (r.A)
HAVING COUNT(r.B) < 3;
}\end{alltt}
Here $R$ is a relation with schema $(A,B)$.   You can assume that the domains of $A$ and $B$ are integers.
Use the encoding and decoding methods described above.
\end{enumerate}

\newpage
We now turn to some problems that relate to query processing in {\tt Spark}.  Note that in {\tt Spark} it is possible to operate on multiple
key-value stores.
\begin{enumerate}[resume]
\item\label{cogroup} 
Let $R(K,V)$ and $S(K,W)$ be two binary key-value pair relations.
You can assume that the domains of $K$, $V$, and $W$ are integers.
Consider the cogroup transformation {\tt R.cogroup(S)} introduced in the
lecture on {\tt Spark}.  

\begin{enumerate}
\item Define a PostgreSQL view {\tt coGroup} that computes a complex-object relation that represent the co-group transformation {\tt R.cogroup(S)}.
Show that this view works.

\item Write a PostgreSQL query that use this {\tt coGroup} view to compute the semi join
$R\, \ltimes\, S$, in other words compute the relation $R \bowtie \pi_{K}(S)$.

\item Write a PostgreSQL query that uses this {\tt coGroup} view to implement
the SQL query

%\begin{alltt}\textcolor{red}{
%SELECT distinct r.K as rK, s.K as sK
%FROM   R r, S s
%WHERE  ARRAY(SELECT r1.V
%             FROM   R r1
%             WHERE  r1.K = r.K) >@ ARRAY(SELECT s1.W
%                                         FROM   S s1
%                                         WHERE  s1.K = s.K);
%}\end{alltt}


\begin{alltt}\textcolor{blue}{
 SELECT distinct r.K as rK, s.K as sK
 FROM   R r, S s
 WHERE  NOT ARRAY(SELECT r1.V
                  FROM   R r1
                  WHERE  r1.K = r.K) && ARRAY(SELECT s1.W
                                              FROM	 S s1
                                              WHERE  s1.K = s.K);
}\end{alltt}                                                  

\end{enumerate}


\item \textcolor{red}{\bf Practice problem--not graded}. Let {\tt A(x)} and {\tt B(x)} be the schemas to represent two set of integers $A$ and $B$.
Consider the {\tt cogroup} transformation introduced in the
lecture on {\tt Spark}.
Using an approach analogous to the one in Problem~\ref{cogroup} solve
the following problems:\footnote{An important aspect of this problem is to represent $A$ and $B$ as a key-value stores.}

\begin{enumerate}
\item Write a PostgreSQL query that uses the cogroup transformation
to compute $A \cap B$.

\item Write a PostgreSQL query that uses the cogroup operator
to compute the symmetric difference of $A$ and $B$, i.e., the expression
$$(A - B) \cup (B-A).$$
\end{enumerate}
\end{enumerate}


\newpage
\section{Graph query languages}

Each of the following problems is a practice problem.

\begin{enumerate}[resume]
\item \textcolor{red}{\bf Practice Problem--not graded}.  Consider the database schema 
{\tt Person}, {\tt Company}, {\tt companyLocation}, {\tt Knows}, {\tt jobSkill}, and {\tt personSkill}.
\begin{enumerate}
\item Specify  an  Entity-Relationship  Diagram  that  models  this  database schema.
\item\label{propertygraphmodel} Specify  the  node  and  relationship  types  of  a  Property  Graph  for this  database  schema.   In  addition,  specify  the  properties,  if  any, associated with each such type.
\end{enumerate}

\item 
\textcolor{red}{\bf Practice Problem--not graded}.
Using the Property Graph model in Problem~\ref{propertygraphmodel},
formulate the following queries in the Cypher query language:
\begin{enumerate}
\item Find the types of the relationships associated with {\tt Person} nodes.
\item Find each person (node) whose name is ‘John’ and has a salary that is at least 50000.
\item Find each jobSkill (node) that is the job skill of a person who knows 
a person who works for 'Amazon' and who has a salary that is at least 50000.
\item Find each person (node) who knows directly or indirectly (i.e., recursively) another person who works for Amazon.
\item Find for each company node, that node along with the number of persons who work for that company
and who have both the Databases and Networks job skills.
\end{enumerate}

\end{enumerate}
\end{document}


